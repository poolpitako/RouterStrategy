# @version 0.3.7
"""
@title Loss On Fee Checker
@author Yearn Finance
@license MIT
@dev 
    Blocks harvests on strategies that would experiece a loss due to fees. 
    Standard healthcheck in unable to catch such losses, thus this special
    purpose contract is useful.
"""

from vyper.interfaces import ERC20
from vyper.interfaces import ERC20Detailed

interface IVault:
    def totalAssets() -> uint256: view
    def managementFee() -> uint256: view
    def performanceFee() -> uint256: view
    def strategies(strategy: address) -> StrategyParams: view
    def lastReport() -> uint256: view
    def totalDebt() -> uint256: view
    def apiVersion() -> String[28]: view

interface IVaultNew:
    def strategies(strategy: address) -> StrategyParamsNew: view

interface IStrategy:
    def vault() -> address: view
    def want() -> address: view

event Sweep:
    sweeper: indexed(address)
    token: indexed(address)
    amount: uint256

struct StrategyParams:
    performanceFee: uint256
    activation: uint256
    debtRatio: uint256
    rateLimit: uint256
    lastReport: uint256
    totalDebt: uint256
    totalGain: uint256
    totalLoss: uint256

struct StrategyParamsNew:
    performanceFee: uint256
    activation: uint256
    debtRatio: uint256
    minDebtPerHarvest: uint256
    maxDebtPerHarvest: uint256
    lastReport: uint256
    totalDebt: uint256
    totalGain: uint256
    totalLoss: uint256 

MAX_BPS: constant(uint256) = 10_000
SECS_PER_YEAR: constant(uint256) = 31_557_600
approved_sweepers: public(HashMap[address, bool])

@external
@view
def check_loss(gain: uint256, loss: uint256, strategy: address = msg.sender) -> uint256:
    return self._check(gain, loss, strategy)

@internal
@view
def _check(gain: uint256, loss: uint256, strategy: address) -> uint256:
    """
    @notice
        Check for losses generated by fees and return a precise amount.
    @param gain - amount of reported gain
    @param loss - amount of reported loss
    @param strategy - strategy to compute for. defaults to msg.sender for use on-chain.
    @return amount of projected loss
    @dev
        Fee calculations replicate logic from vault versions
        0.3.0 - mgmt fee calculated based on total assets in vault
        0.3.1 - mgmt calculated based on total debt of vault
        0.3.2 - fee calculations are same as 0.3.1, but StrategyParams are different
    """

    vault: IVault = IVault(IStrategy(strategy).vault())
    
    management_fee: uint256 = vault.managementFee()
    if management_fee == 0:
        return 0
    
    total_assets: uint256 = vault.totalAssets()
    if total_assets == 0:
        return 0

    last_report: uint256 = vault.lastReport()
    if last_report == 0:
        return 0

    time_since: uint256 = block.timestamp - last_report
    if time_since == 0:
        return 0

    api: String[28] = vault.apiVersion()
    if api == "0.3.0":
        params: StrategyParams = vault.strategies(strategy)
        return self._calc030(vault, gain, loss, management_fee, params.performanceFee, total_assets, time_since)
    if api == "0.3.1":
        params: StrategyParams = vault.strategies(strategy)
        return self._calc031(vault, gain, loss, management_fee, params.performanceFee, time_since)
    if api == "0.3.2":
        params: StrategyParamsNew = IVaultNew(vault.address).strategies(strategy)
        return self._calc031(vault, gain, loss, management_fee, params.performanceFee, time_since)
    else:
        raise # @dev: Vault api version not supported

    return 0

@internal
@view
def _calc030(
    vault: IVault,
    gain: uint256,
    loss: uint256,
    management_fee: uint256,
    strat_perf_fee: uint256,
    total_assets: uint256,
    time_since: uint256
) -> uint256:
    governance_fee: uint256 = (
        total_assets * time_since * management_fee
        / MAX_BPS
        / SECS_PER_YEAR
    )

    if gain > 0:
        strategist_fee: uint256 = gain * strat_perf_fee / MAX_BPS
        performance_fee: uint256 = gain * vault.performanceFee() / MAX_BPS
        governance_fee = governance_fee + strategist_fee + performance_fee

    if gain >= loss:
        gross_profit: uint256 = gain - loss
        if gross_profit >= governance_fee:
            return 0
        else:
            return governance_fee - gross_profit
    else:
        gross_loss: uint256 = loss - gain
        return gross_loss + governance_fee

    return 0

@internal
@view
def _calc031(
    vault: IVault,
    gain: uint256,
    loss: uint256,
    management_fee: uint256,
    strat_perf_fee: uint256,
    time_since: uint256
) -> uint256:
    vault_debt: uint256 = vault.totalDebt()
    governance_fee: uint256 = (
        vault_debt * time_since * management_fee
        / MAX_BPS
        / SECS_PER_YEAR
    )

    if gain > 0:
        strategist_fee: uint256 = gain * strat_perf_fee / MAX_BPS
        performance_fee: uint256 = gain * vault.performanceFee() / MAX_BPS
        governance_fee = governance_fee + strategist_fee + performance_fee

    if gain >= loss:
        gross_profit: uint256 = gain - loss
        if gross_profit >= governance_fee:
            return 0
    else:
        gross_loss: uint256 = loss - gain
        return gross_loss + governance_fee

    return 0

@external
def sweep(token: address):
    """
    @notice Allow governance ms to sweep
    """
    assert msg.sender == 0xFEB4acf3df3cDEA7399794D0869ef76A6EfAff52 # @dev: !approved
    bal: uint256 =  ERC20(token).balanceOf(self)
    ERC20(token).transfer(msg.sender, bal, default_return_value=True)